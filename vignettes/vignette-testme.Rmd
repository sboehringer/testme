---
title: Package documentation
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{Package documentation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: rmarkdown::html_vignette
author: Stefan BÃ¶hringer <r-packages@s-boehringer.org>
---

# Purpose of the package

This package is meant to rapidly develop unit (or integration) tests for your personal library. The author maintains a set of R-scirpts that he re-uses across projects. It is important that the meaning of functions does not change over time so that old analyses can be repeated even with the latest version of the scripts.

Other uses of software testing include coding to specification, where a unit test is written first and an actual function is written later to pass the pre-specified test. While `testme` can be used for this purpose, other packages might be more suitable (e.g. `testthat`).

## Walk through example

Let us assume, we devlop a function that deals with a special case in R where columns from a `data.frame` or `matrix` are selected and simplified to a vector in case a single column is selected (which can be avoided by the `.drop = FALSE` argument). If we want to deal with the result of such a selection (projection) and be able to to use it as a matrix-like structure always, we have to detect and deal with this special case. Let us first find out how to detect the special case.

```{r}
	# our master structure
	m0 = matrix(1:9, ncol = 3);

	sel1 = m0[, 1:2];
	sel2 = m0[, 3];

	print(dim(sel1));
	print(dim(sel2));
```

Aha! `dim` returns `NULL` in case of a vector and something else otherwise. We can therefore use the `dim`-test to detect the special case.

```{r}
	m = sel1;
	print(if (is.null(dim(m))) "is vector" else "is matrix");
	m = sel2;
	print(if (is.null(dim(m))) "is vector" else "is matrix");
```

We can create a column vector with the transpose function like so:

```{r}
	print(t(t(sel2)));
```

Now let us wrap these expresssion into a function (taking only bits and pieces from above):

```{r}
	to.col = function(m) { if (is.null(dim(m))) t(t(m)) else m }
```

Let us check our function again:

```{r}
	print(to.col(sel1));
	print(to.col(sel2));
```

But now, by simply checking your new function, you have created unit tests! We wrap the last part into a testing function:

```{r}
to.col_test = function() {
	# prepare test data
	m0 = matrix(1:9, ncol = 3);
	sel1 = m0[, 1:2];
	sel2 = m0[, 3];

	T1 = to.col(sel1);
	T2 = to.col(sel2);

	TestMe();
}
```
Instead of printing our checks, we assign the results to a variable `Td` where `d` is an integer. Function `TestMe` detects the use of such variables and uses them for the definition of test cases.

That's it. Running the tests will preserve the definition (meaning) of you function. If your tests fail, you know that code using the previous definitions might break.

In the next paragraphs you learn about the options of how to run your tests.

# Workflows

## Testing locally

One main purpose of package `testme` is to allow local testing in a continuous development model. In this model, it is assumed that R-code is re-used across projects and sourced into the different workflows. In order to garuantee consistent code behaviour, testing is required. Test can be held in a single file or in a directory. After changes can be easily tested. Package functions `testmeFile` and `testmeDir` can be used to run these tests. If a standard location for tests exists, it can be configured with `options`.

```{r}
.First = function() {
	options(
		testme = list(
			testsFolder = '~/src/Rtests',
			sourceFiles = c('~/src/Rgeneric.R', '~/src/Rgenetics.R')
		)
	)
}
```

The code above can be put into the `.Rprofile` file. The function `runTests` will query these options if not explicetly provided with arguments. The component `sourceFiles` specifies initialization scripts that load the code that is to be tested by tests in `testsFolder`. Expectations are stored in the subfolder `RtestsExpectations` of `testsFolder` by default.

## Testing packages

If a file contains tests that test functions in an R-package, these tests can be installed into a package source tree using `installPackageTests`. Test files can be used both for local testing and for package testing. The only initialization performed for package tests is to load the package. Other initialization has to be performed in the test files themselves. Except for special cases, it should not be required to perform additional initialization.

# Advanced topics

## Using Expectations

One major optimization in the testing workflow of `testme` is that expectations are created automatically. Sometimes it is required or clearer to provide expectations explicitely. Expectations have to be deparsed R values. The are indicated by variables names `Ed` where `d` is an integer. The deparsing can be performed by function `Deparse` as provided by package `testme` or by the build-in.

```{r}
to.col_test = function() {
	# prepare test data
	m0 = matrix(1:9, ncol = 3);
	sel1 = m0[, 1:2];
	sel2 = m0[, 3];

	T1 = to.col(sel1);
	E1 = "structure(1:6, .Dim = 3:2)";
	T2 = to.col(sel2);
	E2 = "structure(7:9, .Dim = c(3L, 1L))";

	TestMe();
}
```

In the case above, no expectation files would be created and the provided values would be used for comparison instead.

## Comparison modes

Package `compare` is used to compare test values und evaluated expectations for equalness. What is treated as equal can be fine-tuned via argument `mode`. `mode` is a list that forces a particular comparison. Keys are names of test values and values are comparison modes. Supported modes are:

  * compare: call function `compare` (the default)
  * round8: round to 8 digits, then call compare
  * error: the test value is (and should be) an error
  * image: the test produces an image. Images should be compared on a pixel-by-pixel basis

The following example illustrates the use of mode `round8`:

```{r}
	myTests = function() {
		T1 = 1 + 1;
		T2 = sqrt(exp(10));
		TestMe(list(T2 = 'round8'));
	}
```

